import numpy as np
import kornia as K
import kornia.geometry as KG
import torch
from skimage import filters
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from skimage.registration import phase_cross_correlation

from abc import ABC, abstractmethod


class Registrator(ABC):

    @abstractmethod
    def register(self, src_img: np.ndarray, dst_img: np.ndarray) -> None:
        """Initialize the registrator based on a pair of images.
        Any number of channels is accepted. Channels must be the last axis.
        Float images are accepted. Nan values are automatically handled.

        Args:
            src_img (np.ndarray): source image in the format HxWxC.
            dst_img (np.ndarray): image to be used as reference in the format HxWxC.
        """
        pass

    @abstractmethod
    def warp_image(self, src_img: np.ndarray) -> np.ndarray:
        """Warp an image based on the registration parameters generated by calling the register method.
        The input image will be aligned based on the relative shift between the source and destination images
        passed to the register method.

        Args:
            src_img (np.ndarray): image to be warped in the format HxWxC.

        Returns:
            np.ndarray: warped image in the format HxWxC.
        """
        pass


class PCCRegistrator(Registrator):

    def __init__(self, masked: bool = True, max_shift: int = 3, **kwargs):
        """kwargs are passed to the function skimage.registration.phase_cross_correlation.

        Args:
            masked (bool, optional): If True and if reference_mask and moving_mask are provided as kwargs,
            nan values in src_img and dst_img will be used as mask in PCC registration algorithm. Using masked=True
            generally requires a longer execution time. Defaults to True.
            max_shift (int, optional): Maximum shift allowed in pixels. To avoid unexpected results, if a shift
            greater than max_shift is detected, the shift is disregarded and set to 0. Defaults to 3.
        """
        self.masked = masked
        self.max_shift = max_shift
        self.kwargs = kwargs
        # Initialize shift as None to indicate that it has not been created yet
        self.shift = None

    def register(self, src_img: np.ndarray, dst_img: np.ndarray) -> None:
        # Mask is obtained from the first channel of the image.
        # In geospatial images, nodata values are usually common across all channels.
        if self.masked and "reference_mask" not in self.kwargs and "moving_mask" not in self.kwargs:
            reference_mask = np.invert(np.isnan(dst_img)[:, :, 0])
            moving_mask = np.invert(np.isnan(dst_img)[:, :, 0])
            self.kwargs["reference_mask"] = reference_mask
            self.kwargs["moving_mask"] = moving_mask

        src_img = self._prepare_registration_image(src_img)
        dst_img = self._prepare_registration_image(dst_img)
        # Coregistration
        self.shift, error, diffphase = phase_cross_correlation(dst_img, src_img, **self.kwargs)

    def warp_image(self, src_img: np.ndarray) -> np.ndarray:
        assert (
            self.shift is not None
        ), "You must call the register method before calling this method."
        # TODO: scipy.ndimage.shift could be used to apply subpixel shifts

        # Apply pixel shift using slice
        shift = np.round(self.shift).astype(int)
        x_shift, y_shift = shift
        if x_shift > self.max_shift or y_shift > self.max_shift:
            x_shift, y_shift = 0, 0
        y_ini = 0
        y_end = -1
        x_ini = 0
        x_end = -1
        y_ini_replacement = 0
        y_end_replacement = -1
        x_ini_replacement = 0
        x_end_replacement = -1
        if x_shift < 0:
            y_ini = -1 * x_shift
            y_end_replacement = -1 + x_shift
        if x_shift > 0:
            y_end = -1 - x_shift
            y_ini_replacement = x_shift
        if y_shift < 0:
            x_ini = -1 * y_shift
            x_end_replacement = -1 + y_shift
        if y_shift > 0:
            x_end = -1 - y_shift
            x_ini_replacement = y_shift

        from_origin = src_img[y_ini:y_end, x_ini:x_end]
        scr_img_registered = np.zeros_like(src_img)
        scr_img_registered[...] = np.nan
        scr_img_registered[
            y_ini_replacement:y_end_replacement, x_ini_replacement:x_end_replacement
        ] = from_origin

        return scr_img_registered

    # ----------------- Private methods ----------------- #
    def _prepare_registration_image(self, img: np.ndarray) -> np.ndarray:
        img = np.nan_to_num(img, nan=0)
        if img.shape[2] > 1:
            img = _apply_pca(img)
        else:
            img = img[:, :, 0]
        img = filters.sobel(img)
        img_min = np.quantile(img, 0.001)
        img_max = np.quantile(img, 0.999)
        img = img.clip(img_min, img_max)
        return img


class _KorniaRegistratorNanScaler:
    """Helper class to normalize and denormalize image data.
    An offset is added to the normalized data to make sure all values are greater than zero.
    Zero is used to represent padding values"""

    PADDING_VALUE = 0
    PADDING_VALUE_REPLACEMENT = np.nan

    def fit_transform(self, x: np.ndarray, offset: float = 0.0001) -> np.ndarray:
        assert np.isnan(x).sum() == 0, "x cannot have nan values."
        self.min = x.min()
        self.max = x.max()
        self.offset = offset
        self.delta_x = self.max - self.min
        if self.delta_x == 0:
            self.delta_x = 0.0001

        # TODO: Find a better way to handle delta_x == 0. It only happens when the image is a constant value.

        # return ((x - self.min) / (self.max - self.min)) + self.offset
        return ((x - self.min) / self.delta_x) + self.offset

    def inverse_transform(self, x: np.ndarray) -> np.ndarray:
        padded_areas = x == self.PADDING_VALUE
        x = ((x - self.offset) * self.delta_x) + self.min
        x[padded_areas] = self.PADDING_VALUE_REPLACEMENT
        return x


class KorniaRegistrator(Registrator):

    def __init__(self, device_type: str = "cpu", **kwargs):
        """kwargs are passed to the ImageRegistrator constructor (kornia.geometry.ImageRegistrator).

        Args:
            device_type (str, optional): Device to use for the registration. Defaults to "cpu".
        """
        # Initialize registrator as None to indicate that it has not been created yet
        self.registrator = None
        # Configure torch device
        self.device = torch.device(device_type)
        # Set default values for kwargs if they are not provided
        if "model_type" not in kwargs:
            kwargs["model_type"] = "translation"
        if "pyramid_levels" not in kwargs:
            kwargs["pyramid_levels"] = 3
        self.kwargs = kwargs

    def register(self, src_img: np.ndarray, dst_img: np.ndarray) -> None:
        src_img = self._prepare_registration_image(src_img)
        dst_img = self._prepare_registration_image(dst_img)
        # Coregistration
        self.registrator = KG.ImageRegistrator(**self.kwargs).to(self.device)
        _ = self.registrator.register(src_img, dst_img)

    def warp_image(self, src_img: np.ndarray) -> np.ndarray:
        assert (
            self.registrator is not None
        ), "You must call the register method before calling this method."

        src_img_nan_mask = np.isnan(src_img)
        src_img_nan_mask = K.image_to_tensor(src_img_nan_mask, None).float().to(self.device)
        src_img = np.nan_to_num(src_img, nan=0)
        src_scaler = _KorniaRegistratorNanScaler()
        src_img = src_scaler.fit_transform(src_img)
        scr_img = K.image_to_tensor(src_img, None).float().to(self.device)

        scr_img_registered = self.registrator.warp_src_into_dst(scr_img)
        scr_img_registered = K.tensor_to_image(scr_img_registered)
        src_img_nan_mask_registered = self.registrator.warp_src_into_dst(src_img_nan_mask)
        src_img_nan_mask_registered = K.tensor_to_image(src_img_nan_mask_registered)
        # Force mask to be binary
        src_img_nan_mask_registered = src_img_nan_mask_registered > 0.5
        # Apply denormalization
        scr_img_registered = src_scaler.inverse_transform(scr_img_registered)
        # Apply nan values back
        scr_img_registered[src_img_nan_mask_registered] = np.nan
        # Add channels axis if it was removed (may happen if the image is single channel)
        if len(scr_img_registered.shape) == 2:
            scr_img_registered = scr_img_registered[..., np.newaxis]

        return scr_img_registered

    # ----------------- Private methods ----------------- #

    def _prepare_registration_image(self, img: np.ndarray) -> np.ndarray:
        img = np.nan_to_num(img, nan=0)
        if img.shape[2] > 1:
            img = _apply_pca(img)
        else:
            img = img[:, :, 0]
        img = filters.sobel(img)[:, :, np.newaxis]
        img_min = np.quantile(img, 0.001)
        img_max = np.quantile(img, 0.999)
        img = img.clip(img_min, img_max)
        img = _KorniaRegistratorNanScaler().fit_transform(img)
        img = K.image_to_tensor(img, None).float().to(self.device)
        return img


def _apply_pca(img: np.ndarray) -> np.ndarray:
    """Apply PCA to an image and return the first component.

    Args:
        img (np.ndarray): image in the format HxWxC.

    Returns:
        np.ndarray: image in the format HxW.
    """
    y_size, x_size, nb_channels = img.shape
    if nb_channels == 1:
        return img
    X = img.reshape(-1, nb_channels)
    # Normalize X using StandardScaler
    scaler = StandardScaler()
    X_norm = scaler.fit_transform(X)
    # Run PCA
    pca = PCA(n_components=1, random_state=0)
    X_reduced = pca.fit_transform(X_norm)
    # Reshape X_reduced to original shape
    X_reduced = X_reduced.reshape(y_size, x_size)
    return X_reduced
