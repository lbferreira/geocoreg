import numpy as np
import kornia as K
import kornia.geometry as KG
import torch
from skimage import filters
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from skimage.registration import phase_cross_correlation

from abc import ABC, abstractmethod


class Registrator(ABC):

    @abstractmethod
    def register(self, src_img: np.ndarray, dst_img: np.ndarray) -> None:
        """Initialize the registrator based on a pair of images.
        Any number of channels is accepted. Channels must be the last axis.
        Float images are accepted. Nan values are automatically handled.

        Args:
            src_img (np.ndarray): source image in the format HxWxC.
            dst_img (np.ndarray): image to be used as reference in the format HxWxC.
        """
        pass

    @abstractmethod
    def warp_image(self, src_img: np.ndarray) -> np.ndarray:
        """Warp an image based on the registration parameters generated by calling the register method.
        The input image will be aligned based on the relative shift between the source and destination images
        passed to the register method.

        Args:
            src_img (np.ndarray): image to be warped in the format HxWxC.

        Returns:
            np.ndarray: warped image in the format HxWxC.
        """
        pass


class PCCRegistrator(Registrator):

    def __init__(self, **kwargs):
        """kwargs are passed to the function skimage.registration.phase_cross_correlation."""
        self.kwargs = kwargs
        # Initialize shift as None to indicate that it has not been created yet
        self.shift = None

    def register(self, src_img: np.ndarray, dst_img: np.ndarray) -> None:
        src_img = self._prepare_registration_image(src_img)
        dst_img = self._prepare_registration_image(dst_img)
        # Coregistration
        self.shift, error, diffphase = phase_cross_correlation(dst_img, src_img, **self.kwargs)

    def warp_image(self, src_img: np.ndarray) -> np.ndarray:
        assert (
            self.shift is not None
        ), "You must call the register method before calling this method."

        # Apply shift using slice
        shift = np.round(self.shift).astype(int)
        x_shift, y_shift = shift
        y_ini = 0
        y_end = -1
        x_ini = 0
        x_end = -1
        y_ini_replacement = 0
        y_end_replacement = -1
        x_ini_replacement = 0
        x_end_replacement = -1
        if x_shift < 0:
            y_ini = -1 * x_shift
            y_end_replacement = -1 + x_shift
        if x_shift > 0:
            y_end = -1 - x_shift
            y_ini_replacement = x_shift
        if y_shift < 0:
            x_ini = -1 * y_shift
            x_end_replacement = -1 + y_shift
        if y_shift > 0:
            x_end = -1 - y_shift
            x_ini_replacement = y_shift

        from_origin = src_img[y_ini:y_end, x_ini:x_end]
        scr_img_registered = np.zeros_like(src_img)
        scr_img_registered[...] = np.nan
        scr_img_registered[
            y_ini_replacement:y_end_replacement, x_ini_replacement:x_end_replacement
        ] = from_origin

        return scr_img_registered

    # ----------------- Private methods ----------------- #
    def _prepare_registration_image(self, img: np.ndarray) -> np.ndarray:
        img = np.nan_to_num(img, nan=0)
        if img.shape[2] > 1:
            img = _apply_pca(img)
        else:
            img = img[:, :, 0]
        img = filters.sobel(img)
        img_min = np.quantile(img, 0.001)
        img_max = np.quantile(img, 0.999)
        img = img.clip(img_min, img_max)
        return img


class _KoniaRegistratorNanScaler:
    """Helper class to normalize and denormalize image data.
    An offset is added to the normalized data to make sure all values are greater than zero.
    Zero is used to represent padding values"""

    PADDING_VALUE = 0
    PADDING_VALUE_REPLACEMENT = np.nan

    def fit_transform(self, x: np.ndarray, offset: float = 0.0001) -> np.ndarray:
        assert np.isnan(x).sum() == 0, "x cannot have nan values."
        self.min = x.min()
        self.max = x.max()
        self.offset = offset
        self.delta_x = self.max - self.min
        if self.delta_x == 0:
            self.delta_x = 0.0001

        # TODO: Find a better way to handle delta_x == 0. It only happens when the image is a constant value.

        # return ((x - self.min) / (self.max - self.min)) + self.offset
        return ((x - self.min) / self.delta_x) + self.offset

    def inverse_transform(self, x: np.ndarray) -> np.ndarray:
        padded_areas = x == self.PADDING_VALUE
        x = ((x - self.offset) * self.delta_x) + self.min
        x[padded_areas] = self.PADDING_VALUE_REPLACEMENT
        return x


class KoniaRegistrator(Registrator):

    def __init__(self, device_type: str = "cpu", **kwargs):
        """kwargs are passed to the ImageRegistrator constructor (kornia.geometry.ImageRegistrator).

        Args:
            device_type (str, optional): Device to use for the registration. Defaults to "cpu".
        """
        # Initialize registrator as None to indicate that it has not been created yet
        self.registrator = None
        # Configure torch device
        self.device = torch.device(device_type)
        # Set default values for kwargs if they are not provided
        if "model_type" not in kwargs:
            kwargs["model_type"] = "translation"
        if "pyramid_levels" not in kwargs:
            kwargs["pyramid_levels"] = 3
        self.kwargs = kwargs

    def register(self, src_img: np.ndarray, dst_img: np.ndarray) -> None:
        src_img = self._prepare_registration_image(src_img)
        dst_img = self._prepare_registration_image(dst_img)
        # Coregistration
        self.registrator = KG.ImageRegistrator(**self.kwargs).to(self.device)
        _ = self.registrator.register(src_img, dst_img)

    def warp_image(self, src_img: np.ndarray) -> np.ndarray:
        assert (
            self.registrator is not None
        ), "You must call the register method before calling this method."

        src_img_nan_mask = np.isnan(src_img)
        src_img_nan_mask = K.image_to_tensor(src_img_nan_mask, None).float().to(self.device)
        src_img = np.nan_to_num(src_img, nan=0)
        src_scaler = _KoniaRegistratorNanScaler()
        src_img = src_scaler.fit_transform(src_img)
        scr_img = K.image_to_tensor(src_img, None).float().to(self.device)

        scr_img_registered = self.registrator.warp_src_into_dst(scr_img)
        scr_img_registered = K.tensor_to_image(scr_img_registered)
        src_img_nan_mask_registered = self.registrator.warp_src_into_dst(src_img_nan_mask)
        src_img_nan_mask_registered = K.tensor_to_image(src_img_nan_mask_registered)
        # Force mask to be binary
        src_img_nan_mask_registered = src_img_nan_mask_registered > 0.5
        # Apply denormalization
        scr_img_registered = src_scaler.inverse_transform(scr_img_registered)
        # Apply nan values back
        scr_img_registered[src_img_nan_mask_registered] = np.nan
        # Add channels axis if it was removed (may happen if the image is single channel)
        if len(scr_img_registered.shape) == 2:
            scr_img_registered = scr_img_registered[..., np.newaxis]

        return scr_img_registered

    # ----------------- Private methods ----------------- #

    def _prepare_registration_image(self, img: np.ndarray) -> np.ndarray:
        img = np.nan_to_num(img, nan=0)
        if img.shape[2] > 1:
            img = _apply_pca(img)
        else:
            img = img[:, :, 0]
        img = filters.sobel(img)[:, :, np.newaxis]
        img_min = np.quantile(img, 0.001)
        img_max = np.quantile(img, 0.999)
        img = img.clip(img_min, img_max)
        img = _KoniaRegistratorNanScaler().fit_transform(img)
        img = K.image_to_tensor(img, None).float().to(self.device)
        return img


def _apply_pca(img: np.ndarray) -> np.ndarray:
    """Apply PCA to an image and return the first component.

    Args:
        img (np.ndarray): image in the format HxWxC.

    Returns:
        np.ndarray: image in the format HxW.
    """
    y_size, x_size, nb_channels = img.shape
    if nb_channels == 1:
        return img
    X = img.reshape(-1, nb_channels)
    # Normalize X using StandardScaler
    scaler = StandardScaler()
    X_norm = scaler.fit_transform(X)
    # Run PCA
    pca = PCA(n_components=1, random_state=0)
    X_reduced = pca.fit_transform(X_norm)
    # Reshape X_reduced to original shape
    X_reduced = X_reduced.reshape(y_size, x_size)
    return X_reduced
